{
  "version": "2",
  "created_at": "2026-02-01T18:43:57.836845+00:00",
  "updated_at": "2026-02-01T18:48:05.332923+00:00",
  "environment": {
    "python_version": "3.12.8",
    "packages_hash": null,
    "packages_count": 0,
    "cached_at": null
  },
  "packages": {},
  "docs": {
    "str": {
      "package": "str",
      "package_version": null,
      "content": "Python Library Documentation: class str in module builtins\n\nclass s\bst\btr\br(object)\n |  str(object='') -> str\n |  str(bytes_or_buffer[, encoding[, errors]]) -> str\n |\n |  Create a new string object from the given object. If encoding or\n |  errors is specified, then the object must expose a data buffer\n |  that will be decoded using the given encoding and error handler.\n |  Otherwise, returns the result of object.__str__() (if defined)\n |  or repr(object).\n |  encoding defaults to sys.getdefaultencoding().\n |  errors defaults to 'strict'.\n |\n |  Methods defined here:\n |\n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |\n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return bool(key in self).\n |\n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |\n |  _\b__\b_f\bfo\bor\brm\bma\bat\bt_\b__\b_(self, format_spec, /)\n |      Return a formatted version of the string as described by format_spec.\n |\n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |\n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |\n |  _\b__\b_g\bge\bet\btn\bne\bew\bwa\bar\brg\bgs\bs_\b__\b_(...)\n |\n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |\n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |\n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |\n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |\n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |\n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |\n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |\n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |\n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |\n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |\n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |\n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |\n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Return the size of the string in memory, in bytes.\n |\n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |\n |  c\bca\bap\bpi\bit\bta\bal\bli\biz\bze\be(self, /)\n |      Return a capitalized version of the string.\n |\n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |\n |  c\bca\bas\bse\bef\bfo\bol\bld\bd(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |\n |  c\bce\ben\bnt\bte\ber\br(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  c\bco\bou\bun\bnt\bt(...)\n |      S.count(sub[, start[, end]]) -> int\n |\n |      Return the number of non-overlapping occurrences of substring sub in\n |      string S[start:end].  Optional arguments start and end are\n |      interpreted as in slice notation.\n |\n |  e\ben\bnc\bco\bod\bde\be(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |\n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |\n |  e\ben\bnd\bds\bsw\bwi\bit\bth\bh(...)\n |      S.endswith(suffix[, start[, end]]) -> bool\n |\n |      Return True if S ends with the specified suffix, False otherwise.\n |      With optional start, test S beginning at that position.\n |      With optional end, stop comparing S at that position.\n |      suffix can also be a tuple of strings to try.\n |\n |  e\bex\bxp\bpa\ban\bnd\bdt\bta\bab\bbs\bs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |\n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |\n |  f\bfi\bin\bnd\bd(...)\n |      S.find(sub[, start[, end]]) -> int\n |\n |      Return the lowest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |\n |      Return -1 on failure.\n |\n |  f\bfo\bor\brm\bma\bat\bt(...)\n |      S.format(*args, **kwargs) -> str\n |\n |      Return a formatted version of S, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  f\bfo\bor\brm\bma\bat\bt_\b_m\bma\bap\bp(...)\n |      S.format_map(mapping) -> str\n |\n |      Return a formatted version of S, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  i\bin\bnd\bde\bex\bx(...)\n |      S.index(sub[, start[, end]]) -> int\n |\n |      Return the lowest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |\n |      Raises ValueError when the substring is not found.\n |\n |  i\bis\bsa\bal\bln\bnu\bum\bm(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |\n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |\n |  i\bis\bsa\bal\blp\bph\bha\ba(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |\n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |\n |  i\bis\bsa\bas\bsc\bci\bii\bi(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |\n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |\n |  i\bis\bsd\bde\bec\bci\bim\bma\bal\bl(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |\n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |\n |  i\bis\bsd\bdi\big\bgi\bit\bt(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |\n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |\n |  i\bis\bsi\bid\bde\ben\bnt\bti\bif\bfi\bie\ber\br(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |\n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |\n |  i\bis\bsl\blo\bow\bwe\ber\br(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |\n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |\n |  i\bis\bsn\bnu\bum\bme\ber\bri\bic\bc(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |\n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |\n |  i\bis\bsp\bpr\bri\bin\bnt\bta\bab\bbl\ble\be(self, /)\n |      Return True if the string is printable, False otherwise.\n |\n |      A string is printable if all of its characters are considered printable in\n |      repr() or if it is empty.\n |\n |  i\bis\bss\bsp\bpa\bac\bce\be(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |\n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |\n |  i\bis\bst\bti\bit\btl\ble\be(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |\n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |\n |  i\bis\bsu\bup\bpp\bpe\ber\br(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |\n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |\n |  j\bjo\boi\bin\bn(self, iterable, /)\n |      Concatenate any number of strings.\n |\n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |\n |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n |\n |  l\blj\bju\bus\bst\bt(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  l\blo\bow\bwe\ber\br(self, /)\n |      Return a copy of the string converted to lowercase.\n |\n |  l\bls\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  p\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |\n |  r\bre\bem\bmo\bov\bve\bep\bpr\bre\bef\bfi\bix\bx(self, prefix, /)\n |      Return a str with the given prefix string removed if present.\n |\n |      If the string starts with the prefix string, return string[len(prefix):].\n |      Otherwise, return a copy of the original string.\n |\n |  r\bre\bem\bmo\bov\bve\bes\bsu\buf\bff\bfi\bix\bx(self, suffix, /)\n |      Return a str with the given suffix string removed if present.\n |\n |      If the string ends with the suffix string and that suffix is not empty,\n |      return string[:-len(suffix)]. Otherwise, return a copy of the original\n |      string.\n |\n |  r\bre\bep\bpl\bla\bac\bce\be(self, old, new, count=-1, /)\n |      Return a copy with all occurrences of substring old replaced by new.\n |\n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |\n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |\n |  r\brf\bfi\bin\bnd\bd(...)\n |      S.rfind(sub[, start[, end]]) -> int\n |\n |      Return the highest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |\n |      Return -1 on failure.\n |\n |  r\bri\bin\bnd\bde\bex\bx(...)\n |      S.rindex(sub[, start[, end]]) -> int\n |\n |      Return the highest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |\n |      Raises ValueError when the substring is not found.\n |\n |  r\brj\bju\bus\bst\bt(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  r\brp\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |\n |  r\brs\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the end of the string and works to the front.\n |\n |  r\brs\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  s\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the front of the string and works to the end.\n |\n |      Note, str.split() is mainly useful for data that has been intentionally\n |      delimited.  With natural text that includes punctuation, consider using\n |      the regular expression module.\n |\n |  s\bsp\bpl\bli\bit\btl\bli\bin\bne\bes\bs(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |\n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |\n |  s\bst\bta\bar\brt\bts\bsw\bwi\bit\bth\bh(...)\n |      S.startswith(prefix[, start[, end]]) -> bool\n |\n |      Return True if S starts with the specified prefix, False otherwise.\n |      With optional start, test S beginning at that position.\n |      With optional end, stop comparing S at that position.\n |      prefix can also be a tuple of strings to try.\n |\n |  s\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  s\bsw\bwa\bap\bpc\bca\bas\bse\be(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |\n |  t\bti\bit\btl\ble\be(self, /)\n |      Return a version of the string where each word is titlecased.\n |\n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |\n |  t\btr\bra\ban\bns\bsl\bla\bat\bte\be(self, table, /)\n |      Replace each character in the string using the given translation table.\n |\n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |\n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |\n |  u\bup\bpp\bpe\ber\br(self, /)\n |      Return a copy of the string converted to uppercase.\n |\n |  z\bzf\bfi\bil\bll\bl(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |\n |      The string is never truncated.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  m\bma\bak\bke\bet\btr\bra\ban\bns\bs(...)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n",
      "is_structured": false,
      "cached_at": "2026-02-01T18:43:57.943017+00:00",
      "hit_count": 0
    },
    "requests.get": {
      "package": "requests",
      "package_version": "2.32.4",
      "content": {
        "name": "requests.get",
        "found": true,
        "error": null,
        "type": "function",
        "object_type": "function",
        "import_statement": "from requests.api import get",
        "signature": "get(url, params=None, **kwargs)",
        "short_description": "Sends a GET request.",
        "full_docstring": "Sends a GET request.\n\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary, list of tuples or bytes to send\n    in the query string for the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
        "parameters": [
          {
            "name": "url",
            "required": true,
            "kind": "positional_or_keyword"
          },
          {
            "name": "params",
            "default": "None",
            "required": false,
            "kind": "positional_or_keyword"
          },
          {
            "name": "kwargs",
            "required": false,
            "kind": "var_keyword"
          }
        ],
        "source_file": "/home/pavan/miniforge3/lib/python3.12/site-packages/requests/api.py"
      },
      "is_structured": true,
      "cached_at": "2026-02-01T18:48:05.197973+00:00",
      "hit_count": 0
    },
    "pathlib.Path": {
      "package": "pathlib",
      "package_version": null,
      "content": {
        "name": "pathlib.Path",
        "found": true,
        "error": null,
        "type": "type",
        "object_type": "class",
        "import_statement": "from pathlib import Path",
        "signature": "Path(*args, **kwargs)",
        "short_description": "PurePath subclass that can make system calls.",
        "full_docstring": "PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
        "parameters": [
          {
            "name": "args",
            "required": false,
            "kind": "var_positional"
          },
          {
            "name": "kwargs",
            "required": false,
            "kind": "var_keyword"
          }
        ],
        "related": [
          "PosixPath",
          "PurePath",
          "PurePosixPath",
          "PureWindowsPath",
          "WindowsPath"
        ],
        "source_file": "/home/pavan/miniforge3/lib/python3.12/pathlib.py",
        "methods": [
          {
            "name": "__enter__",
            "signature": "(self)"
          },
          {
            "name": "__exit__",
            "signature": "(self, t, v, tb)"
          },
          {
            "name": "__init__",
            "signature": "(self, *args, **kwargs)",
            "description": "Initialize self.  See help(type(self)) for accurate signature."
          },
          {
            "name": "absolute",
            "signature": "(self)",
            "description": "Return an absolute version of this path by prepending the current"
          },
          {
            "name": "as_posix",
            "signature": "(self)",
            "description": "Return the string representation of the path with forward (/)"
          },
          {
            "name": "as_uri",
            "signature": "(self)",
            "description": "Return the path as a 'file' URI."
          },
          {
            "name": "chmod",
            "signature": "(self, mode, *, follow_symlinks=True)",
            "description": "Change the permissions of the path, like os.chmod()."
          },
          {
            "name": "cwd",
            "signature": "()",
            "description": "Return a new path pointing to the current working directory."
          },
          {
            "name": "exists",
            "signature": "(self, *, follow_symlinks=True)",
            "description": "Whether this path exists."
          },
          {
            "name": "expanduser",
            "signature": "(self)",
            "description": "Return a new path with expanded ~ and ~user constructs"
          },
          {
            "name": "glob",
            "signature": "(self, pattern, *, case_sensitive=None)",
            "description": "Iterate over this subtree and yield all existing files (of any"
          },
          {
            "name": "group",
            "signature": "(self)",
            "description": "Return the group name of the file gid."
          },
          {
            "name": "hardlink_to",
            "signature": "(self, target)",
            "description": "Make this path a hard link pointing to the same file as *target*."
          },
          {
            "name": "home",
            "signature": "()",
            "description": "Return a new path pointing to the user's home directory (as"
          },
          {
            "name": "is_absolute",
            "signature": "(self)",
            "description": "True if the path is absolute (has both a root and, if applicable,"
          },
          {
            "name": "is_block_device",
            "signature": "(self)",
            "description": "Whether this path is a block device."
          },
          {
            "name": "is_char_device",
            "signature": "(self)",
            "description": "Whether this path is a character device."
          },
          {
            "name": "is_dir",
            "signature": "(self)",
            "description": "Whether this path is a directory."
          },
          {
            "name": "is_fifo",
            "signature": "(self)",
            "description": "Whether this path is a FIFO."
          },
          {
            "name": "is_file",
            "signature": "(self)",
            "description": "Whether this path is a regular file (also True for symlinks pointing"
          },
          {
            "name": "is_junction",
            "signature": "(self)",
            "description": "Whether this path is a junction."
          },
          {
            "name": "is_mount",
            "signature": "(self)",
            "description": "Check if this path is a mount point"
          },
          {
            "name": "is_relative_to",
            "signature": "(self, other, /, *_deprecated)",
            "description": "Return True if the path is relative to another path or False."
          },
          {
            "name": "is_reserved",
            "signature": "(self)",
            "description": "Return True if the path contains one of the special names reserved"
          },
          {
            "name": "is_socket",
            "signature": "(self)",
            "description": "Whether this path is a socket."
          },
          {
            "name": "is_symlink",
            "signature": "(self)",
            "description": "Whether this path is a symbolic link."
          },
          {
            "name": "iterdir",
            "signature": "(self)",
            "description": "Yield path objects of the directory contents."
          },
          {
            "name": "joinpath",
            "signature": "(self, *pathsegments)",
            "description": "Combine this path with one or several arguments, and return a"
          },
          {
            "name": "lchmod",
            "signature": "(self, mode)",
            "description": "Like chmod(), except if the path points to a symlink, the symlink's"
          },
          {
            "name": "lstat",
            "signature": "(self)",
            "description": "Like stat(), except if the path points to a symlink, the symlink's"
          },
          {
            "name": "match",
            "signature": "(self, path_pattern, *, case_sensitive=None)",
            "description": "Return True if this path matches the given pattern."
          },
          {
            "name": "mkdir",
            "signature": "(self, mode=511, parents=False, exist_ok=False)",
            "description": "Create a new directory at this given path."
          },
          {
            "name": "open",
            "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
            "description": "Open the file pointed to by this path and return a file object, as"
          },
          {
            "name": "owner",
            "signature": "(self)",
            "description": "Return the login name of the file owner."
          },
          {
            "name": "read_bytes",
            "signature": "(self)",
            "description": "Open the file in bytes mode, read it, and close the file."
          },
          {
            "name": "read_text",
            "signature": "(self, encoding=None, errors=None)",
            "description": "Open the file in text mode, read it, and close the file."
          },
          {
            "name": "readlink",
            "signature": "(self)",
            "description": "Return the path to which the symbolic link points."
          },
          {
            "name": "relative_to",
            "signature": "(self, other, /, *_deprecated, walk_up=False)",
            "description": "Return the relative path to another path identified by the passed"
          },
          {
            "name": "rename",
            "signature": "(self, target)",
            "description": "Rename this path to the target path."
          },
          {
            "name": "replace",
            "signature": "(self, target)",
            "description": "Rename this path to the target path, overwriting if that path exists."
          },
          {
            "name": "resolve",
            "signature": "(self, strict=False)",
            "description": "Make the path absolute, resolving all symlinks on the way and also"
          },
          {
            "name": "rglob",
            "signature": "(self, pattern, *, case_sensitive=None)",
            "description": "Recursively yield all existing files (of any kind, including"
          },
          {
            "name": "rmdir",
            "signature": "(self)",
            "description": "Remove this directory.  The directory must be empty."
          },
          {
            "name": "samefile",
            "signature": "(self, other_path)",
            "description": "Return whether other_path is the same or not as this file"
          },
          {
            "name": "stat",
            "signature": "(self, *, follow_symlinks=True)",
            "description": "Return the result of the stat() system call on this path, like"
          },
          {
            "name": "symlink_to",
            "signature": "(self, target, target_is_directory=False)",
            "description": "Make this path a symlink pointing to the target path."
          },
          {
            "name": "touch",
            "signature": "(self, mode=438, exist_ok=True)",
            "description": "Create this file with the given access mode, if it doesn't exist."
          },
          {
            "name": "unlink",
            "signature": "(self, missing_ok=False)",
            "description": "Remove this file or link."
          },
          {
            "name": "walk",
            "signature": "(self, top_down=True, on_error=None, follow_symlinks=False)",
            "description": "Walk the directory tree from this directory, similar to os.walk()."
          },
          {
            "name": "with_name",
            "signature": "(self, name)",
            "description": "Return a new path with the file name changed."
          },
          {
            "name": "with_segments",
            "signature": "(self, *pathsegments)",
            "description": "Construct a new path object from any number of path-like objects."
          },
          {
            "name": "with_stem",
            "signature": "(self, stem)",
            "description": "Return a new path with the stem changed."
          },
          {
            "name": "with_suffix",
            "signature": "(self, suffix)",
            "description": "Return a new path with the file suffix changed.  If the path"
          },
          {
            "name": "write_bytes",
            "signature": "(self, data)",
            "description": "Open the file in bytes mode, write to it, and close the file."
          },
          {
            "name": "write_text",
            "signature": "(self, data, encoding=None, errors=None, newline=None)",
            "description": "Open the file in text mode, write to it, and close the file."
          }
        ],
        "attributes": []
      },
      "is_structured": true,
      "cached_at": "2026-02-01T18:48:05.332909+00:00",
      "hit_count": 0
    }
  },
  "stats": {
    "cache_hits": 0,
    "cache_misses": 3,
    "evictions": 0
  }
}